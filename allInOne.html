<!DOCTYPE html>
<html>
<head>
    <title>Balance visualizer</title>
    <style>
        .deposit {
            color: green;
        }

        .withdrawal {
            color: red;
        }

        /* Define CSS styles for circular areas */
        .area {
            border: 1px solid #999; /* Dark gray border */
            border-radius: 10px; /* Rounded corners for a circular appearance */
            padding: 20px;
            margin: 20px;
            background: #f5f5f5; /* Very light gray background */
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2); /* Add a subtle shadow */
            font-family: Arial, sans-serif; /* Set the font family */
        }

        /* Style for titles */
        .area h3 {
            text-align: center;
            border-bottom: 1px solid #999; /* Thin separator line below the title */
            margin-bottom: 10px; /* Add some space below the separator */
            padding-bottom: 15px;
        }

        /* Style for the scrollable content */
        .scrollable-content {
            max-height: 300px; /* Define the maximum height for scrollable area */
            overflow-y: auto; /* Enable vertical scrolling when content overflows */
        }

        /* Style for buttons */
        button {
            background: #007BFF; /* Blue background color */
            color: white; /* White text color */
            padding: 10px 20px;
            border: solid 1px white;
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial, sans-serif; /* Set the font family */
        }

        /* Style for disabled buttons */
        button:disabled {
            background: #ccc; /* Gray background for disabled buttons */
            cursor: not-allowed; /* Show not-allowed cursor for disabled buttons */
        }

        /* Style for the table with alternating row colors */
        .styled-table {
            width: 100%;
            border-collapse: collapse;
        }

        .styled-table th {
            background-color: #f0f0f0; /* Light gray header background */
        }

        .styled-table th,
        .styled-table td {
            padding: 8px;
            border: 1px solid #999; /* Lighter gray border for cells */
        }

        .styled-table tbody tr:nth-child(even) {
            background-color: #f8f8f8; /* Alternating row background color */
        }

        .styled-table tbody tr:nth-child(odd) {
            background-color: #ffffff; /* Alternating row background color */
        }


        /* Style for input fields */
        input[type="date"],
        input[type="number"] {
            padding: 5px;
            border: 1px solid #ccc; /* Light gray border */
            border-radius: 5px;
        }

        /* Style for the separator above the canvas */
        .separator-above-canvas {
            border-top: 1px solid #999; /* Thin separator line above the canvas */
            margin-top: 20px; /* Add some space above the separator */
        }
    </style>
</head>
<body>
    <h1 style="text-align: center; font-family: Arial, sans-serif;">Account Balance Visualization</h1>

    <!-- Account statement upload Area -->
    <div class="area" id="accountStatementArea">
        <h3>Upload an Account Statement</h3>
        <label for="accountType">Select Account Type:</label>
        <select id="accountType">
            <option value="eToro">eToro</option>
            <option value="Binance">Binance</option>
        </select>
        <form id="uploadForm">
            <label for="accountStatementFileInput">Upload a <span id="fileTypeText">PDF</span> File:</label>
            <input type="file" id="accountStatementFileInput" accept=".pdf, .txt">
        </form>

        <div id="result">
            <!-- Display extracted daily balance here -->
        </div>
    </div>

<!-- Cash Flows Area -->
<div class="area" id="cashFlowArea">
    <h3>Cash Flows</h3>
    <table id="cashFlowInputFields">
        <tr>
            <td>Date: <input type="date" id="cashFlowDate"></td>
            <td>Amount: <input type="number" id="cashFlowAmount"></td>
            <td id="transaction-type"></td>
            <td><button id="deleteAllButton">ðŸ—‘ Clear All</button></td>
            <td><button id="addDeposit">+ Add Deposit</button><button id="addWithdraw">- Add Withdrawal</button></td>
        </tr>
    </table>
    <button id="cashFlowUpdateBalanceButton">Apply</button>
    <div class="scrollable-content">
        <table id="cashFlowsTable" class="styled-table scrollable-content">
            <thead>
                <tr>
                    <th>Date</th>
                    <th>Amount</th>
                    <th>Type</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="3" style="text-align: center;">No cash flow data</td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<!-- Balances Table Area -->
<div class="area" id="balancesArea">
    <h3>Balances</h3>
    <table id="balancesInputFields">
        <tr>
            <td>Date: <input type="date" id="balanceDate"></td>
            <td>Balance: <input type="number" id="balanceAmount"></td>
            <td><button id="addBalance">+ Add Balance</button></td>
        </tr>
    </table>
    <div class="scrollable-content">
        <table id="balancesTable" class="styled-table">
            <thead>
                <tr>
                    <th>Date</th>
                    <th>Balance</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="2" style="text-align: center;">No balance data</td>
                </tr>
            </tbody>
        </table>
    </div>
</div>


    <!-- Yearly Average Computation Area -->
    <div class="area" id="accountStatisticsArea">
        <h3>Account Statistics</h3>
        <p>Yearly Average Balance: <span id="yearly-average">N/A</span></p>
        <p>Final Balance (on 31st December of the same year): <span id="final-balance">N/A</span></p>
    </div>

    <div class="area" id="commandsArea">
        <button id="resetButton">Reset Data</button>
        <button id="downloadButton" disabled>Download Data</button>
        <button id="uploadButton" disabled>Upload Data</button>
    </div>

    <canvas id="balancesGraph" width="400" height="200"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.0.943/pdf.min.js"></script>
    <script>
//TODO Interactive Brokers
//TODO reset all data button (replaces clear cash flows button)
//TODO balance with/without equities
//TODO cash flows should be "applied" to current balances by overwriting balances and recomputing from cash flows
//TODO account statistics (final balance and average) should be computed automatically every time data is modified
//TODO uploading an account statement should reset all the other data
//TODO download txt with all data
//TODO support viewing separate trading accounts and viewing aggregated data
//TODO interactive graph (hovering with mouse shows dot over graph at current coordinate and tooltip with value)
//TODO add some way to freeze the page while elaborating and track progress

//----------,
// utils.js |
//----------,

function daysInYear(year) {
    return ((year % 4 === 0 && year % 100 > 0) || year %400 == 0) ? 366 : 365;
}

//TODO allow specifying date format and parse date accordingly
function extractDayFromDate(timestamp, format)
{
    // Split the timestamp into date and time parts
    const [datePart, timePart] = timestamp.split(' ');

    // Split the date part into day, month, and year
    const splitDate = datePart.split('-').map(Number);

    format = format.toLowerCase()
    var year = null;
    var month = null;
    var day = null;
    for(var i=0; i<format.length; i+=1)
    {
        var dateComponent = format.charAt(i);
        switch(dateComponent)
        {
            case "y":
            {
                year = splitDate[i]
                break;   
            }
            case "m":
            {
                month = splitDate[i]
                break;   
            }
            case "d":
            {
                day = splitDate[i]
                break;   
            }
        }
    }

    //console.log(day)
    //console.log(month)
    //console.log(year)
    
    // Create a JavaScript Date object with the date part
    const jsDate = new Date(year, month - 1, day,0,0,0,0);

    return jsDate;
}
        
// Helper function to parse timestamps (adjust as needed)
function parseTimestamp(timestampStr) {
    // Implement your timestamp parsing logic here
    return new Date(timestampStr);
}

// Helper function to get a string representing the date (yyyy-mm-dd)
function getDateString(date) {
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    return `${year}-${month}-${day}`;
}

var getDaysArray = function(s, e, inMilliseconds=false) {
    for(var a=[], d=new Date(s); d<=new Date(e); d.setDate(d.getDate()+1))
    { 
        var newDate = new Date(d);
        if(inMilliseconds) newDate = newDate.getTime();
        a.push(newDate);
    }
    return a;
};    
        
const getFirstItemInMap = map => Array.from(map)[0]
const getFirstKeyInMap = map => Array.from(map)[0][0]
const getFirstValueInMap = map => Array.from(map)[0][1]

const getLastItemInMap = map => Array.from(map)[map.size-1]
const getLastKeyInMap = map => Array.from(map)[map.size-1][0]
const getLastValueInMap = map => Array.from(map)[map.size-1][1]

const dayOfYear = date => Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);

function createArray(start, end) {
    let result = [];
    for (let i = start; i <= end; i++) {
        result.push(i);
    }
    return result;
}

function createDaysOfYearArray(currentYear) {
    return createArray(1,daysInYear(currentYear))
}


//-----------------,
// account_data.js |
//-----------------,

//TODO use sparse arrays for balances: avoid the need to specify one balance for each day
// but instead use the "sparse" ones


let dateToCashFlow = new Map();
let dateToBalance = new Map();
let dailyBalances = [];
let yearlyAverage = null;
let finalBalance = null;

// Draw a simple cash flow graph
const balancesGraphCanvas = document.getElementById("balancesGraph");
const balancesGraphContext = balancesGraphCanvas.getContext("2d");


//---------------
//| Update data |
//---------------

updateDataCallback = function() {
    saveDataToLocalStorage();
    updateVisualizedData();
    drawBalancesGraph(dailyBalances)
}

function updateTables() {
    updateCashFlowTable();
    updateBalancesTable();
}

function updateAccountStatistics() {
    var yearlyAverageStr = "N\\A";
    var finalBalanceStr = "N\\A";
    
    if(dailyBalances.length > 0)
    {
        computeFinalBalance();
        computeYearlyAverage();
        finalBalanceStr = `${finalBalance.toFixed(2)}`
        yearlyAverageStr = `${yearlyAverage.toFixed(2)}`
    }

    document.getElementById("final-balance").innerHTML = finalBalanceStr;
    document.getElementById("yearly-average").innerHTML = yearlyAverageStr;
}

function updateVisualizedData() {
    updateTables();
    updateAccountStatistics();
    resetCashFlowInputFields();
    drawBalancesGraph();
}

// Cash flows

function addCashFlow(dateInMilliseconds, amount, isDeposit) {

    if (!dateInMilliseconds || isNaN(amount)) {
        alert("Please enter a valid date and amount.");
        return;
    }

    dateToCashFlow.set(dateInMilliseconds, {
        dateInMilliseconds: dateInMilliseconds,
        amount: isDeposit ? amount : -amount
    });

    dateToCashFlow = new Map([...dateToCashFlow.entries()].sort());

    dailyBalances = computeDailyBalancesFromCashFlows()
    dateToBalance = computeSparseBalancesFromCashFlows()
    saveDataToLocalStorage();
    updateVisualizedData();
}

function deleteCashFlow(eventTarget) {
    //console.log(eventTarget.index)
    dateToCashFlow.delete(eventTarget.date);
    dailyBalances = computeDailyBalancesFromCashFlows()
    saveDataToLocalStorage();
    updateVisualizedData();

}

function updateCashFlowTable() {
    resetCashFlowsTable(dateToCashFlow.size > 0);
    const table = document.getElementById("cashFlowsTable");
    index = 0;
    for(let [date, cashFlowEntry] of dateToCashFlow.entries())
    {
        const transactionType = cashFlowEntry.amount>=0 ? "Deposit" : "Withdrawal";
        const newRow = table.insertRow(table.rows.length);
        newRow.insertCell(0).textContent = new Date(cashFlowEntry.dateInMilliseconds).toLocaleDateString();
        newRow.insertCell(1).textContent = cashFlowEntry.amount;
        const transactionTypeCell = newRow.insertCell(2);
        transactionTypeCell.textContent = transactionType 
        transactionTypeCell.className = transactionType.toLowerCase();
        var deleteBtn = document.createElement('input');
        deleteBtn.type = "button";
        deleteBtn.className = "delete";
        deleteBtn.value = "ðŸ—‘";
        deleteBtn.date = date;
        newRow.appendChild(deleteBtn);
        deleteBtn.addEventListener("click", (evt) => {deleteCashFlow(evt.target)});
        index+=1;
    }
    resetInputFields();
}

// Balances


function addBalance(dateInMilliseconds, amount) {

    if (!dateInMilliseconds || isNaN(amount)) {
        alert("Please enter a valid date and amount.");
        return;
    }

    dateToBalance.set(dateInMilliseconds, {
        dateInMilliseconds: dateInMilliseconds,
        amount: amount
    });

    dateToBalance = new Map([...dateToBalance.entries()].sort());

    dailyBalances = computeDailyBalancesFromSparseBalances()
    saveDataToLocalStorage();
    updateVisualizedData();
}

function deleteBalance(eventTarget) {
    //console.log(eventTarget.index)
    dateToBalance.delete(eventTarget.date);
    dailyBalances = computeDailyBalancesFromSparseBalances()
    saveDataToLocalStorage();
    updateVisualizedData();

}

function updateBalancesTable() {
    const table = document.getElementById("balancesTable");
    resetBalancesTable(dateToBalance.size > 0);
    index = 0;
    console.log(dateToBalance)
    for(let [date, balanceEntry] of dateToBalance.entries())
    {
        const newRow = table.insertRow(table.rows.length);
        newRow.insertCell(0).textContent = new Date(date).toLocaleDateString();
        newRow.insertCell(1).textContent = balanceEntry.amount;
        var deleteBtn = document.createElement('input');
        deleteBtn.type = "button";
        deleteBtn.className = "delete";
        deleteBtn.value = "ðŸ—‘";
        deleteBtn.date = date;
        newRow.appendChild(deleteBtn);
        deleteBtn.addEventListener("click", (evt) => {deleteBalance(evt.target)});
        index+=1;
    }
    resetInputFields();
}

function drawBalancesGraph() {
    balancesGraphContext.clearRect(0, 0, balancesGraphCanvas.width, balancesGraphCanvas.height);
    balancesGraphCanvas.width = document.body.clientWidth;

    balancesGraphContext.lineWidth = 2;
    balancesGraphContext.strokeStyle="#000000";
    balancesGraphContext.strokeRect(0, 0, balancesGraphCanvas.width, balancesGraphCanvas.height);
    balancesGraphContext.stroke();

    if(dailyBalances.length == 0)
    {
        resetBalancesGraph();
        return;
    }

    // Find the first and last transaction dates
    //console.log(dailyBalances)
    console.log("Updating balances graph")
    const totalDays = dailyBalances.length;
    
    const maxBalance = Math.max(...dailyBalances)*1.5;
    //console.log(maxBalance)

    const firstBalance = dailyBalances[0];
    const horizontalOffset = 0;
    const verticalOffset = balancesGraphCanvas.height/4;

    const x = horizontalOffset;                    
    const dataPointY = (balancesGraphCanvas.height - verticalOffset/2) - ((firstBalance / maxBalance) * (balancesGraphCanvas.height - verticalOffset/2));
    balancesGraphContext.fillStyle = "red";
    balancesGraphContext.strokeStyle = "red";
    balancesGraphContext.beginPath();
    balancesGraphContext.moveTo(x, dataPointY);

    dailyBalances.forEach((balance, index) => {
        const x = horizontalOffset + Math.floor((index/totalDays)*balancesGraphCanvas.width);     
        const dataPointY = balancesGraphCanvas.height - verticalOffset/2 - (Math.floor((balance / maxBalance) * (balancesGraphCanvas.height - verticalOffset/2)));
        //console.log(x)
        //console.log(dataPointY)
        balancesGraphContext.lineTo(x, dataPointY);
        balancesGraphContext.stroke();
    });

    const arrowWidth = 10;
    const arrowHeadHeight = 10;
    const arrowHeight = 30;
    dateToCashFlow.forEach((entry, index) => {
        // Draw arrows for deposits (green upwards arrows)
        if (entry.amount > 0) {
            balancesGraphContext.fillStyle = "green";
            balancesGraphContext.beginPath();
            balancesGraphContext.moveTo(x, balancesGraphCanvas.height - arrowHeight);
            balancesGraphContext.lineTo(x - arrowWidth/2, balancesGraphCanvas.height - arrowHeadHeight);
            balancesGraphContext.lineTo(x + arrowWidth/2, balancesGraphCanvas.height - arrowHeadHeight);
            balancesGraphContext.fill();
        }
        // Draw arrows for withdrawals (red downwards arrows)
        else if (entry.amount < 0) {
            balancesGraphContext.fillStyle = "red";
            balancesGraphContext.beginPath();
            balancesGraphContext.moveTo(x, balancesGraphCanvas.height - 10);
            balancesGraphContext.lineTo(x - 5, balancesGraphCanvas.height - 20);
            balancesGraphContext.lineTo(x + 5, balancesGraphCanvas.height - 20);
            balancesGraphContext.fill();
        }
    });
}


//--------------
//| Reset data |
//--------------

function resetData() {
    dateToCashFlow = new Map();
    dateToBalance = new Map();
    dailyBalances = [];
    yearlyAverage = null;
    finalBalance = null;
    clearLocalStorage();
    resetVisualizedData();
    console.log("Data reset")
}

function resetVisualizedData() {
    resetInputFields();
    resetTables();
    resetAccountStatistics();
}



function resetCashFlowInputFields() {
    document.getElementById("cashFlowDate").value = "";
    document.getElementById("cashFlowAmount").value = "";
}

function resetBalanceInputFields() {
    document.getElementById("balanceDate").value = "";
    document.getElementById("balanceAmount").value = "";
}

function resetInputFields() {
    resetAccountStatementInputFields();
    resetCashFlowInputFields();
    resetBalanceInputFields();
}

function resetAccountStatementInputFields() {
    document.getElementById("accountStatementFileInput").value = null;
}

function resetAccountStatistics() {
    var yearlyAverageStr = "N\\A";
    var finalBalanceStr = "N\\A";
    document.getElementById("final-balance").innerHTML = finalBalanceStr;
    document.getElementById("yearly-average").innerHTML = yearlyAverageStr;
}



function resetCashFlowsTable(empty = false) {
    const table = document.getElementById("cashFlowsTable");
    table.innerHTML = ""
    if(!empty)
    {
        table.innerHTML = "\
        <thead>\
            <tr>\
                <th>Date</th>\
                <th>Amount</th>\
                <th>Type</th>\
            </tr>\
        </thead>\
        <tbody>\
            <tr>\
                <td colspan=\"3\" style=\"text-align: center;\">No cash flow data</td>\
            </tr>\
        </tbody>\
        "
    }
}

function resetBalancesTable(empty = false) {
    const table = document.getElementById("balancesTable");
    table.innerHTML = ""
    if(!empty)
    {
        table.innerHTML = "\
        <thead>\
            <tr>\
                <th>Date</th>\
                <th>Balance</th>\
            </tr>\
        </thead>\
        <tbody>\
            <tr>\
                <td colspan=\"\" style=\"text-align: center;\">No balance data</td>\
            </tr>\
        </tbody>\
        "
    }
}

function resetTables() {
    resetCashFlowsTable();
    resetBalancesTable();
}



function resetBalancesGraph() {
    balancesGraphContext.clearRect(0, 0, balancesGraphCanvas.width, balancesGraphCanvas.height);
    balancesGraphContext.lineWidth = 2;
    balancesGraphContext.fillStyle="#f5f5f5";
    balancesGraphContext.fillRect(0, 0, balancesGraphCanvas.width, balancesGraphCanvas.height);

    // Set font properties
    balancesGraphContext.font = 'bold 20px Arial'; // Font size and style
    balancesGraphContext.fillStyle = 'black'; // Font color
    balancesGraphContext.textAlign = 'center'; // Text alignment

    // Calculate the center coordinates
    const centerX = balancesGraphCanvas.width / 2;
    const centerY = balancesGraphCanvas.height / 2;

    // Write "No balance data" in the center
    balancesGraphContext.fillText('No balance data', centerX, centerY);
    return;
}



function deleteAllCashFlows() {
    dateToCashFlow = new Map();
    dateToBalance = new Map();
    dailyBalances = new Map();
    resetInputFields();
    resetVisualizedData();
}


//---------------
//| Computation |
//---------------
function computeDailyBalancesFromSparseBalances() {
    if (dateToBalance.size == 0) {
        return;
    }

    dateToBalance = new Map([...dateToBalance.entries()].sort());

    // Find the first and last transaction dates
    const firstDate = new Date(getFirstKeyInMap(dateToBalance));
    const lastDate = new Date(getLastKeyInMap(dateToBalance));
    
    //Get the current year
    const currentYear = firstDate.getFullYear();

    //Make sure that all balances refer to the same year
    if (currentYear !== lastDate.getFullYear()) {
        alert("Transactions span multiple years. Yearly average cannot be calculated.");
        return;
    }
    
    // Calculate the number of days between the first and last transaction

    const totalDays = daysInYear(currentYear);
    var balanceDays = createArray(1,totalDays);
    
    const dateToBalanceArr = [...dateToBalance]
    const dayToBalance = new Map(dateToBalanceArr.map(
        ([date, balanceEntry]) => 
        [
            dayOfYear(new Date(date)), {amount: balanceEntry.amount}
        ]
    ))
            
    const balances = [];
    var currentBalance = 0;
    for(let day of balanceDays)
    {
        if(dayToBalance.has(day))
        {
            currentBalance = dayToBalance.get(day).amount;
        }
        balances.push(currentBalance);
    }

    document.getElementById("final-balance").innerHTML = `${balances[balances.length-1].toFixed(2)}`;

    return balances;
}

function computeSparseBalancesFromCashFlows() {
    if (dateToCashFlow.length === 0) {
        alert("No cash flow data available.");
        return;
    }

    dateToCashFlow = new Map([...dateToCashFlow.entries()].sort());

    // Find the first and last transaction dates
    const firstDate = new Date(getFirstKeyInMap(dateToCashFlow));
    const lastDate = new Date(getLastKeyInMap(dateToCashFlow));

    const currentYear = firstDate.getFullYear();
    
    if (currentYear !== lastDate.getFullYear()) {
        alert("Transactions span multiple years. Yearly average cannot be calculated.");
        return;
    }
    

    var dateToBalance = new Map();
    var currentBalance = 0;
    for(let [date, cashFlowEntry] of dateToCashFlow.entries())
    {
        currentBalance += cashFlowEntry.amount;
        dateToBalance.set(date, {amount: currentBalance});
    }

    return dateToBalance;
}

function computeDailyBalancesFromCashFlows() {
    if (dateToCashFlow.length === 0) {
        alert("No cash flow data available.");
        return;
    }

    dateToCashFlow = new Map([...dateToCashFlow.entries()].sort());

    // Find the first and last transaction dates
    const firstDate = new Date(getFirstKeyInMap(dateToCashFlow));
    const lastDate = new Date(getLastKeyInMap(dateToCashFlow));

    const currentYear = firstDate.getFullYear();
    
    if (currentYear !== lastDate.getFullYear()) {
        alert("Transactions span multiple years. Yearly average cannot be calculated.");
        return;
    }
    

    const totalDays = daysInYear(currentYear);
    var cashFlowDays = createArray(1,totalDays);
    
    const dateToCashFlowArr = [...dateToCashFlow]
    const dayToCashFlow = new Map(dateToCashFlowArr.map(
        ([date, cashFlowEntry]) => 
        [
            dayOfYear(new Date(date)), {amount: cashFlowEntry.amount}
        ]
    ))
                
    const balances = [];
    var currentBalance = 0;
    for(let day of cashFlowDays)
    {
        if(dayToCashFlow.has(day))
        {
            currentBalance += dayToCashFlow.get(day).amount;
        }
        balances.push(currentBalance);
    }

    return balances;
}

function computeFinalBalance() {
    finalBalance = dailyBalances[dailyBalances.length-1]
}

function computeYearlyAverage() {
    var yearlyBalance = 0;
    for(var balance of dailyBalances)
    {
        yearlyBalance += balance
    }

    yearlyAverage = yearlyBalance / dailyBalances.length;
}


//------------,
// storage.js |
//------------,

// Function to save cash flow data to localStorage
function saveDataToLocalStorage() {
    console.log("Saving data to local storage...")
    localStorage.setItem('dateToCashFlowData', JSON.stringify(dateToCashFlow, replacer));
    localStorage.setItem('dateToBalanceData', JSON.stringify(dateToBalance, replacer));
    localStorage.setItem('dailyBalancesData', JSON.stringify(dailyBalances, replacer));
}

// Function to retrieve cash flow data from localStorage
function loadDataFromLocalStorage(updateCallback) {
    console.log("Loading data from local storage...")
    const dateToCashFlowData = localStorage.getItem('dateToCashFlowData');
    if (dateToCashFlowData) {
        dateToCashFlow = JSON.parse(dateToCashFlowData, reviver);
        console.log("dateToCashFlow loaded from localStorage")
    }

    const dateToBalanceData = localStorage.getItem('dateToBalanceData');
    if (dateToBalanceData) {
        dateToBalance = JSON.parse(dateToBalanceData, reviver);
        console.log("dateToBalance loaded from localStorage")
    }

    const dailyBalances = localStorage.getItem('dailyBalances');
    if (dailyBalances) {
        dailyBalances = JSON.parse(dailyBalances, reviver);
        console.log("dailyBalances loaded from localStorage")
    }
    
    if(dateToCashFlowData || dateToBalanceData || dailyBalances)
    {
        updateCallback();
    }
}

function clearLocalStorage() {
    localStorage.clear();
}

//Needed to JSON.parse an ES6 Map
function reviver(key, value) {
    if(typeof value === 'object' && value !== null) {
        if (value.dataType === 'Map') {
        return new Map(value.value);
        }
    }
    return value;
}
         
//Needed to JSON.stringify an ES6 Map
function replacer(key, value) {
    if(value instanceof Map) {
        return {
        dataType: 'Map',
        value: Array.from(value.entries()), // or with spread: value: [...value]
        };
    } else {
        return value;
    }
}

//---------------------------------,
// account_statement_processing.js |
//---------------------------------,

//-------------------
//| Data extraction |
//-------------------

async function processAccountStatementFile(file, accountType, updateCallback)
{

    if (accountType === "Binance") {
        if (!file || !file.name.endsWith(".txt")) {
            alert("Please select a .txt file for Binance account statements.");
            return;
        }
    } else {
        if (!file || !file.name.endsWith(".pdf")) {
            alert("Please select a PDF file for eToro or Interactive Brokers account statements.");
            return;
        }
    }        

    switch(accountType)
    {
        case "eToro": case "Interactive Brokers":
        {
            processAccountPDFStatementFile(file, accountType, updateCallback);
            break;                            
        }
        case "Binance":
        {
            processTxtAccountStatementFile(file, accountType, updateCallback);
            break;
        }
        default:
        {
            alert("Unknown account platform: "+accountType);
            return
        }
    }
}

async function processAccountPDFStatementFile(accountStatementFile, accountType, updateCallback) {
    
    console.log(accountStatementFile)

    //Step 2: Read the file using file reader
    var fileReader = new FileReader();  

    fileReader.onload = function() {

        //Step 4:turn array buffer into typed array
        var typedarray = new Uint8Array(this.result);

        //Step 5:pdfjs should be able to read this
        const loadingTask = pdfjsLib.getDocument(typedarray);
        loadingTask.promise.then(async function(pdf) {

            if (!pdf) {
                alert("Please select a PDF file.");
                return;
            }

            var dateToOperation = null;
            switch(accountType)
            {
                case "eToro":
                {
                    // Call a function to extract a date -> operation map from the PDF file
                    dateToOperation = await extractDateToOperationFromeToroAccountStatement(pdf);
                    //console.log(dateToOperation)
                    //We will have a balance for each operation so not a balance for all days
                    // but only for days where an operation has occurred
                    dateToBalance = extractDailyEquitiesFromeToroOperations(dateToOperation);
                    //console.log(dateToBalance)

                    break;                            
                }
                case "Interactive Brokers":
                {
                    break;
                }
                default:
                {
                    alert("Unknown account platform: "+accountType);
                    return
                }
            }
        }).then(() => {

            //A balance for each day (map day (1-365) -> account balance)
            dailyBalances = computeDailyBalancesFromSparseBalances(dateToBalance);
            updateCallback();
        });                           

    };
    
    //Step 3:Read the file as ArrayBuffer
    fileReader.readAsArrayBuffer(accountStatementFile);
}

async function processTxtAccountStatementFile(accountStatementFile, accountType, updateCallback)
{
    var fileReader = new FileReader();  

    fileReader.onload = function(event) {
        console.log("fileReader.onload")

        const fileContent = event.target.result;

        if (!fileContent) {
            alert("Please select a file.");
            return;
        }

        var dateToOperation = null;
        //console.log(fileContent)
        switch(accountType)
        {
            case "Binance":
            {
                // Call a function to extract a date -> operation map from the PDF file
                dateToOperation = extractDateToOperationFromBinanceAccountStatement(fileContent);
                //We will have a balance for each operation so not a balance for all days
                // but only for days where an operation has occurred
                dateToBalance = extractDailyEquitiesFromBinanceOperations(dateToOperation);
                console.log(dateToBalance)

                break;                            
            }
            default:
            {
                alert("Unknown account platform: "+accountType);
                return
            }
        }

        
        //A balance for each day (map day (1-365) -> account balance)
        dailyBalances = computeDailyBalancesFromSparseBalances(dateToBalance);
        updateCallback();
    };

    fileReader.onerror = function (event) {
        reject(new Error("Error while reading the file."));
    };
    
    //Step 3:Read the file as text
    fileReader.readAsText(accountStatementFile);
}

//---------
//| eToro |
//---------

function extractDailyEquitiesFromeToroOperations(dateToOperation)
{
    //console.log(dateToOperation)
    var dateToDailyBalance = new Map();
    //var previousDateInMilliseconds = null;
    var previousDate = null;
    var previousEquity = null;
    for(let operation of dateToOperation)
    {
        //console.log(operation.date)
        var parsedDate = extractDayFromDate(operation.date, "dmy");
        //console.log(parsedDate)
        var parsedDateInMilliseconds = parsedDate.getTime();
        //console.log(new Date(parsedDateInMilliseconds))
        var parsedEquity = parseFloat(operation.realizedEquity);
        if(previousDate == null)
        {
            previousDate = parsedDateInMilliseconds;
            previousEquity = parsedEquity
        }
        else if(previousDate != parsedDateInMilliseconds)
        {
            dateToDailyBalance.set(previousDate, {amount: previousEquity});
            previousDate = parsedDateInMilliseconds;
            previousEquity = parsedEquity
        }
        else continue;
    }

    return dateToDailyBalance;
}

async function extractDateToOperationFromeToroAccountStatement(pdfDocument) {
    const totalPages = pdfDocument.numPages;

    var firstAccountActivityPage = -1;
    var lastAccountActivityPage = -1;
    for (let pageNum = 1; pageNum <= totalPages && lastAccountActivityPage == -1; pageNum++) {
        const page = await pdfDocument.getPage(pageNum);
        const textContent = await page.getTextContent();
        const items = textContent.items;

        //console.log("Scanning page: "+pageNum)

        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const text = item.str.trim();

            //console.log("Text: "+text)
            if (text.toLowerCase().includes("account activity")) {
                firstAccountActivityPage = pageNum
                console.log("Found beginning of account activity at page: "+pageNum)
            } else if (text.toLowerCase().includes("net dividend received")) {
                lastAccountActivityPage = pageNum-1;
                console.log("Found end of account activity at page: "+pageNum)
                break;
            }
        }
    }

    if(firstAccountActivityPage == -1 || lastAccountActivityPage == -1)
    {
        alert("No Account Activity found. Are you sure this is an eToro account statement? For bug reports contact ing.emanuele.musumeci@gmail.com.")
        return
    }

    allOperations = [];
    for(let pageNum = firstAccountActivityPage; pageNum <= lastAccountActivityPage; pageNum+=1)
    {
        const page = await pdfDocument.getPage(pageNum)
        var pageOperations = await extractOperationsFromEToroAccountStatement(page)
        allOperations.push(...pageOperations)
    }

    return allOperations;
}

async function extractOperationsFromEToroAccountStatement(page)
{
    const textContent = await page.getTextContent();
    const items = textContent.items;
    var currentRow = []
    var operations = []
    var pageHeader = true;
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const text = item.str.trim();

        if(text.match(/^\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2}$/) || i === items.length - 1)
        {
            pageHeader = false;
            if(currentRow.length > 0)
            {
                operations.push(await processEToroOperation(currentRow))
                currentRow = []
            }                    
        }
        if(pageHeader) continue;
        currentRow.push(text)
    }
    return operations;
}

async function processEToroOperation(fields)
{
    currentOperation = {
        date: fields[0],
        accountType: null,
        type: fields[1],
        currency: null,
        details: fields[2],
        amount: fields[3],
        realizedEquityChange: fields[4],
        realizedEquity: fields[5],
        balance: fields[6],
        positionID: null   
    };

    if(fields.length === 8) 
        currentOperation.positionID = fields[7];

    return currentOperation;
}

//-----------
//| Binance |
//-----------

function extractDateToOperationFromBinanceAccountStatement(txtFile) 
{
    // Split the file content into rows and ignore first and last rows
    var fileRows = txtFile.split("\n").slice(1);
    fileRows = fileRows.slice(0,fileRows.length-1);

    var allOperations = extractOperationsFromBinanceAccountStatement(fileRows)
    return allOperations;
}

function extractOperationsFromBinanceAccountStatement(fileRows)
{
    var operations = [];
    for(var row of fileRows)
    {
        var fields = row.split(",");
        operations.push(processBinanceOperation(fields))
    }
    return operations;
}

//Binance provides an equity changes on an operation-by-operation basis, therefore, to know
//the current balances, we need to accumulate the current equities
function extractDailyEquitiesFromBinanceOperations(dateToOperation)
{
    var dateToDailyBalance = new Map();
    var previousDate = null;
    var currentEquity = 0;
    for(let operation of dateToOperation)
    {
        console.log(operation.date)
        var parsedDate = extractDayFromDate(operation.date, "ymd");
        console.log(parsedDate)
        var parsedDateInMilliseconds = parsedDate.getTime();
        console.log(new Date(parsedDateInMilliseconds))
        var parsedEquityChange = parseFloat(operation.realizedEquityChange);
        if(previousDate == null)
        {
            previousDate = parsedDateInMilliseconds;
            currentEquity = currentEquity + parsedEquityChange
        }
        else if(previousDate != parsedDateInMilliseconds)
        {
            dateToDailyBalance.set(previousDate, {amount: currentEquity});
            previousDate = parsedDateInMilliseconds;
            currentEquity = currentEquity + parsedEquityChange
        }
        else continue;
    }

    return dateToDailyBalance;
}

function processBinanceOperation(fields)
{
    var currentOperation = {
        date: fields[1],
        accountType: fields[2],
        type: fields[3],
        currency: fields[4],
        details: null,
        amount: null,
        realizedEquityChange: fields[5],
        realizedEquity: null,
        balance: null,
        positionID: null   
    };

    return currentOperation;
}

        //const ratesEndpoint = "http://api.exchangeratesapi.io/v1/";
        //const ratesAPIkey = "c9b603162444cd5ad266ccec717146e1";
        //const convertCurrencyCheckbox = document.getElementById("convertCurrency");

        
        //-----------
        //| Storage |
        //-----------
        // Load data from localStorage when the page has been loaded (if available)
        window.addEventListener("load", function(event) {
            loadDataFromLocalStorage(updateVisualizedData);
            updateVisualizedData();
        });


        //---------------------
        //| Account statement |
        //---------------------
        //Account platform choice combobox
        document.getElementById("accountType").addEventListener("change", function (evt) {
            const selectedAccountType = evt.target.value;
            document.getElementById("fileTypeText").textContent = selectedAccountType === "Binance" ? ".txt" : "PDF";
        });

        //Account statement file upload
        const accountStatementFileInput = document.getElementById("accountStatementFileInput");
        accountStatementFileInput.addEventListener("change", async (e) => {
            e.preventDefault();
            var file = accountStatementFileInput.files[0];
            const accountType = document.getElementById("accountType").value;
            processAccountStatementFile(file, accountType, updateDataCallback)
            
        });


        //--------------------
        //| Cash flows table |
        //--------------------
        const cashFlowDateInput = document.getElementById("cashFlowDate");
        const cashFlowAmountInput = document.getElementById("cashFlowAmount");
        
        //Cash flow deposit button
        document.getElementById("addDeposit").addEventListener("click", () => {
            addCashFlow(new Date(cashFlowDateInput.value).getTime(), parseFloat(cashFlowAmountInput.value), true)
        });
        
        //Cash flow withdraw button
        document.getElementById("addWithdraw").addEventListener("click", () => {
            addCashFlow(new Date(cashFlowDateInput.value).getTime(), parseFloat(cashFlowAmountInput.value), false)
        });
        

        //------------------
        //| Balances table |
        //------------------
        const balanceDateInput = document.getElementById("balanceDate");
        const balanceAmountInput = document.getElementById("balanceAmount");

        //Cash flow deposit button
        document.getElementById("addBalance").addEventListener("click", () => {
            addBalance(new Date(balanceDateInput.value).getTime(), parseFloat(balanceAmountInput.value), true)
        });

        //--------------------
        //| Control commands |
        //--------------------
        //Reset all data button
        document.getElementById("resetButton").addEventListener("click", () => {resetData()});


        //-----------------
        //| Balance graph |
        //-----------------
        //...        
    </script>
</body>
</html>
